<!-- Copyright (c) 2024 Gary Oberbrunner
     SPDX-License-Identifier: MIT -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Travel Time Monitor</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        line-height: 1.6;
      }
      h2 {
        margin-top: 5px;
        margin-bottom: 5px;
      }
      .travel-info {
        border: 1px solid #ccc;
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
        background: #f9f9f9;
      }
      .travel-grid {
        display: grid;
        grid-template-columns: auto auto auto;
        width: fit-content;
        gap: 12px;
        margin: 0px 0;
        background: #f9f9f9;
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #ccc;
      }
      .grid-header {
        font-weight: bold;
        padding: 10px;
        background: #eee;
        border-radius: 4px;
      }
      .grid-label {
        font-weight: bold;
      }
      .grid-cell {
        background: white;
        border-radius: 4px;
        min-height: 1.5em;
      }
      .grid-row {
        display: contents;
      }
      .grid2 {
        display: grid;
        grid-template-columns: auto auto;
      }
      @media (max-width: 600px) {
        .grid2 {
          grid-template-columns: 1fr; /* one column */
        }
      }
      .long-drive-time {
        color: #995200;
        background: #ffffdd;
      }
      .very-long-drive-time {
        color: #995200;
        font-weight: bold;
        background: #ffff88;
      }
      .timestamp {
        color: #666;
        font-size: 0.9em;
      }
      .cache-status {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 3px;
        font-size: 0.85em;
        margin-left: 8px;
      }
      .cache-fresh {
        background-color: #e6ffe6;
        color: #006600;
      }
      .cache-stale {
        background-color: #fff3e6;
        color: #995200;
      }
      .error {
        color: #ff0000;
        background: #ffe6e6;
        padding: 10px;
        border-radius: 3px;
        margin-top: 10px;
        display: none;
      }
      .refresh-button {
        background: #4caf50;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 10px;
      }
      .refresh-button:hover {
        background: #45a049;
      }
      .refresh-button:disabled {
        background: #cccccc;
        cursor: not-allowed;
      }
      .next-update {
        color: #666;
        font-size: 0.9em;
      }
      .settings-container {
        margin-top: 20px;
        padding: 20px;
        border: 1px solid #ccc;
        border-radius: 5px;
        background: #f5f5f5;
      }
      .settings-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
        user-select: none;
      }
      .settings-header h3 {
        margin: 0;
      }
      .settings-toggle {
        font-size: 1.2em;
        transition: transform 0.2s;
      }
      .settings-toggle.open {
        transform: rotate(90deg);
      }
      .settings-content {
        display: none;
        margin-top: 15px;
      }
      .settings-content.open {
        display: block;
      }
      .settings-group {
        margin-bottom: 15px;
      }
      .settings-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      .settings-group input,
      .settings-group select {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 3px;
        font-size: 14px;
      }
      .settings-group small {
        display: block;
        margin-top: 3px;
        color: #666;
        font-size: 0.85em;
      }
      .settings-actions {
        display: flex;
        gap: 10px;
        margin-top: 15px;
      }
      .settings-button {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }
      .settings-button.save {
        background: #4caf50;
        color: white;
      }
      .settings-button.save:hover {
        background: #45a049;
      }
      .settings-button.reset {
        background: #f44336;
        color: white;
      }
      .settings-button.reset:hover {
        background: #da190b;
      }
      .walking-info {
        background: #f0f8ff;
        padding: 8px 12px;
        margin: 10px 0;
        border-radius: 4px;
        font-size: 0.9em;
        border-left: 3px solid #2196f3;
      }
      .train-catchable {
        background: #e8f5e9;
        padding: 2px 6px;
        border-radius: 3px;
        border: 1px solid #4caf50;
      }
      .train-missed {
        opacity: 0.5;
        text-decoration: line-through;
      }
      .walking-icon {
        margin-right: 5px;
      }
      .loading {
        color: #666;
        font-style: italic;
      }
      .error-state {
        color: #ff0000;
        background: #ffe6e6;
        padding: 4px 8px;
        border-radius: 3px;
      }
      .success-message {
        background: #e6ffe6;
        color: #006600;
      }
      .retry-info {
        font-size: 0.85em;
        color: #666;
        margin-top: 5px;
      }
    </style>
  </head>
  <body>
    <div class="travel-info">
      <div class="travel-info">
        <div class="grid2">
          <h2>üöá Next Red Line Trains at Kendall/MIT</h2>
          <p class="next-update">
            Next update in: <span id="next-update-mbta">-</span>
          </p>
        </div>
        <div id="walking-info" class="walking-info" style="display: none">
          <span class="walking-icon">üö∂</span>
          <span id="walking-text"></span>
        </div>
        <div id="trains">Loading...</div>
      </div>
      <h2>üöò Current Driving Times</h2>
      <div class="travel-grid">
        <div class="grid-row">
          <div class="grid-label">‚Üí To Dest</div>
          <div class="grid-cell" id="to-time">Loading...</div>
          <div class="grid-cell" id="to-distance">Loading...</div>
        </div>

        <div class="grid-row">
          <div class="grid-label">‚Üê To Home</div>
          <div class="grid-cell" id="from-time">Loading...</div>
          <div class="grid-cell" id="from-distance">Loading...</div>
        </div>
      </div>
      <div class="grid2">
        <div class="timestamp">
          Last updated: <span id="timestamp">-</span>
          <span id="cache-status" class="cache-status"></span>
        </div>
        <div class="next-update">
          Next update in: <span id="next-update">-</span>
        </div>
      </div>
      <button
        id="refresh-button"
        class="refresh-button"
        onclick="manualRefresh()"
      >
        Refresh Now
      </button>
      <p id="error-message" class="error"></p>
    </div>

    <div class="settings-container">
      <div class="settings-header" onclick="toggleSettings()">
        <h3>‚öôÔ∏è Settings</h3>
        <span class="settings-toggle" id="settings-toggle">‚ñ∂</span>
      </div>
      <div class="settings-content" id="settings-content">
        <div class="settings-group">
          <label for="home-address">Home Address</label>
          <input
            type="text"
            id="home-address"
            placeholder="e.g., 795 Massachusetts Ave, Cambridge, MA 02139"
          />
          <small>Your home address for driving time calculations</small>
        </div>
        <div class="settings-group">
          <label for="destination-address">Destination Address</label>
          <input
            type="text"
            id="destination-address"
            placeholder="e.g., 77 Massachusetts Ave, Cambridge, MA 02139"
          />
          <small>Your destination address for driving time calculations</small>
        </div>
        <div class="settings-group">
          <label for="mbta-station">MBTA Station</label>
          <select id="mbta-station">
            <option value="place-knncl">Kendall/MIT</option>
            <option value="place-chmnl">Charles/MGH</option>
            <option value="place-pktrm">Park Street</option>
            <option value="place-dwnxg">Downtown Crossing</option>
            <option value="place-sstat">South Station</option>
            <option value="place-harsq">Harvard</option>
            <option value="place-portr">Porter</option>
            <option value="place-davis">Davis</option>
            <option value="place-cntsq">Central Square</option>
            <option value="place-asmnl">Alewife</option>
            <option value="place-jfk">JFK/UMass</option>
            <option value="place-andrw">Andrew</option>
            <option value="place-brdwy">Broadway</option>
          </select>
          <small>Select your Red Line station for train predictions</small>
        </div>
        <div class="settings-actions">
          <button class="settings-button save" onclick="saveSettings()">
            Save Settings
          </button>
          <button class="settings-button reset" onclick="resetSettings()">
            Reset to Defaults
          </button>
        </div>
      </div>
    </div>

    <div style="background: #e8f4fd; border: 1px solid #4a90e2; padding: 15px; border-radius: 5px; margin-top: 20px;">
      <strong>‚ÑπÔ∏è About this applet:</strong> This applet is for people whose home isn't on the Red Line, but work or some other destination is. It shows driving times both ways, and next train arrival times, to help you plan your transportation.
    </div>

    <script>
      // Security utilities
      class SecurityUtils {
        static sanitizeInput(input) {
          if (typeof input !== 'string') return '';
          // Remove potentially dangerous characters and limit length
          return input.trim().slice(0, 200).replace(/[<>"'&]/g, '');
        }

        static validateAddress(address) {
          if (!address || typeof address !== 'string') return false;

          const sanitized = this.sanitizeInput(address);
          if (sanitized.length < 10) return false;

          // Basic address format validation
          const hasNumbers = /\d/.test(sanitized);
          const hasLetters = /[a-zA-Z]/.test(sanitized);
          const hasCommaOrState = /(,|MA|Massachusetts|Boston|Cambridge)/i.test(sanitized);

          // Check for suspicious patterns
          const suspiciousPatterns = [
            /<script/i, /javascript:/i, /data:/i, /vbscript:/i,
            /onload/i, /onerror/i, /onclick/i, /alert\(/i, /eval\(/i,
            /\{\{/,  // Template injection
            /\$\{/,  // Template literals
            /\[\[/   // Some template engines
          ];

          if (suspiciousPatterns.some(pattern => pattern.test(sanitized))) {
            return false;
          }

          return hasNumbers && hasLetters && hasCommaOrState;
        }

        static escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        }
      }

      // Configuration management
      class ConfigManager {
        constructor() {
          this.defaults = {
            homeAddress: "",
            destinationAddress: "",
            mbtaStation: "place-knncl",
            mbtaStationName: "Kendall/MIT",
            isFirstVisit: true,
          };
        }

        load() {
          const stored = localStorage.getItem("travelTimeConfig");
          if (stored) {
            try {
              const config = JSON.parse(stored);
              return { ...this.defaults, ...config, isFirstVisit: false };
            } catch (e) {
              console.error("Failed to parse stored config:", e);
            }
          }
          return this.defaults;
        }

        hasValidAddresses() {
          const config = this.load();
          return (
            SecurityUtils.validateAddress(config.homeAddress) &&
            SecurityUtils.validateAddress(config.destinationAddress)
          );
        }

        save(config) {
          localStorage.setItem("travelTimeConfig", JSON.stringify(config));
        }

        reset() {
          localStorage.removeItem("travelTimeConfig");
          return this.defaults;
        }

        getStationName(stationId) {
          const stations = {
            "place-knncl": "Kendall/MIT",
            "place-chmnl": "Charles/MGH",
            "place-pktrm": "Park Street",
            "place-dwnxg": "Downtown Crossing",
            "place-sstat": "South Station",
            "place-harsq": "Harvard",
            "place-portr": "Porter",
            "place-davis": "Davis",
            "place-cntsq": "Central Square",
            "place-asmnl": "Alewife",
            "place-jfk": "JFK/UMass",
            "place-andrw": "Andrew",
            "place-brdwy": "Broadway",
          };
          return stations[stationId] || "Unknown Station";
        }
      }

      // State management class to handle application state
      class TravelTimeMonitor {
        constructor() {
          this.configManager = new ConfigManager();
          this.config = this.configManager.load();
          this.state = {
            lastRequestTimeDriving: 0,
            lastRequestTimeMBTA: 0,
            timers: {
              driving: null,
              mbta: null,
            },
            isRefreshing: false,
          };

          this.constants = {
            UPDATE_INTERVAL_DRIVING: 5 * 60 * 1000,
            UPDATE_INTERVAL_MBTA: 1 * 60 * 1000,
            MIN_REQUEST_INTERVAL: 10000,
            ENDPOINTS: {
              MBTA: "https://travel-time-worker.garyo.workers.dev/mbta",
              DRIVING: "https://travel-time-worker.garyo.workers.dev/driving",
            },
          };

          this.updateUIWithConfig();

          this.init();
        }

        init() {
          this.loadSettingsUI();

          // Check if this is first visit or no addresses configured
          if (!this.configManager.hasValidAddresses()) {
            // Open settings panel automatically
            const content = document.getElementById("settings-content");
            const toggle = document.getElementById("settings-toggle");
            content.classList.add("open");
            toggle.classList.add("open");

            // Show a message
            this.showError(
              "Please configure your home and destination addresses to get started"
            );

            // Still fetch MBTA data since station is set
            this.fetchMBTAData();
          } else {
            // Normal startup with both fetches
            this.fetchDrivingData();
            this.fetchMBTAData();
          }

          this.setupRefreshButton();
        }

        loadSettingsUI() {
          document.getElementById("home-address").value =
            this.config.homeAddress;
          document.getElementById("destination-address").value =
            this.config.destinationAddress;
          document.getElementById("mbta-station").value =
            this.config.mbtaStation;
        }

        updateUIWithConfig() {
          const stationName = this.configManager.getStationName(
            this.config.mbtaStation
          );
          const mbtaHeader = document.querySelector(".grid2 h2");
          if (mbtaHeader) {
            mbtaHeader.textContent = `üöá Next Red Line Trains at ${stationName}`;
          }
        }

        updateConfig(newConfig) {
          this.config = { ...this.config, ...newConfig };
          this.configManager.save(this.config);
          this.updateUIWithConfig();
        }

        setupRefreshButton() {
          const refreshButton = document.getElementById("refresh-button");
          refreshButton.onclick = () => this.handleManualRefresh();
        }

        async handleManualRefresh() {
          if (this.state.isRefreshing) return;

          const now = Date.now();
          const timeSinceLastDriving = now - this.state.lastRequestTimeDriving;
          const timeSinceLastMBTA = now - this.state.lastRequestTimeMBTA;

          if (
            timeSinceLastDriving < this.constants.MIN_REQUEST_INTERVAL ||
            timeSinceLastMBTA < this.constants.MIN_REQUEST_INTERVAL
          ) {
            const waitTime = Math.ceil(
              (this.constants.MIN_REQUEST_INTERVAL -
                Math.min(timeSinceLastDriving, timeSinceLastMBTA)) /
                1000
            );
            this.showError(
              `Please wait ${waitTime} seconds before refreshing again.`
            );
            return;
          }

          this.setRefreshState(true);

          try {
            await Promise.all([
              this.fetchDrivingData(true),
              this.fetchMBTAData(true),
            ]);
          } finally {
            this.setRefreshState(false);
          }
        }

        setRefreshState(isRefreshing) {
          this.state.isRefreshing = isRefreshing;
          const refreshButton = document.getElementById("refresh-button");
          refreshButton.disabled = isRefreshing;
        }

        showError(message, isPersistent = false) {
          const errorElement = document.getElementById("error-message");
          errorElement.textContent = SecurityUtils.escapeHtml(message);
          errorElement.style.display = "block";

          if (!isPersistent) {
            setTimeout(() => {
              errorElement.style.display = "none";
            }, 5000); // Increased timeout for better UX
          }
        }

        showSuccess(message) {
          // Reuse error element but with different styling
          const errorElement = document.getElementById("error-message");
          errorElement.textContent = SecurityUtils.escapeHtml(message);
          errorElement.style.display = "block";
          errorElement.style.background = "#e6ffe6";
          errorElement.style.color = "#006600";

          setTimeout(() => {
            errorElement.style.display = "none";
            // Reset to error styling
            errorElement.style.background = "#ffe6e6";
            errorElement.style.color = "#ff0000";
          }, 3000);
        }

        clearError() {
          const errorElement = document.getElementById("error-message");
          errorElement.style.display = "none";
          errorElement.style.background = "#ffe6e6";
          errorElement.style.color = "#ff0000";
        }

        showLoading(elementId, message = "Loading...") {
          const element = document.getElementById(elementId);
          if (element) {
            element.textContent = message;
            element.className = "";
          }
        }

        async fetchWithTimeout(url, timeout = 15000) {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);

          try {
            const response = await fetch(url, { signal: controller.signal });

            if (!response.ok) {
              let errorMessage = `Server error (${response.status})`;

              if (response.status === 429) {
                errorMessage = "Rate limit exceeded. Please wait before trying again.";
              } else if (response.status >= 500) {
                errorMessage = "Server is temporarily unavailable. Please try again later.";
              } else if (response.status === 404) {
                errorMessage = "Service endpoint not found. Please check your configuration.";
              } else if (response.status >= 400) {
                errorMessage = "Invalid request. Please check your addresses.";
              }

              throw new Error(errorMessage);
            }

            const data = await response.json();
            if (!data) {
              throw new Error("Received empty response from server");
            }

            return data;
          } catch (error) {
            if (error.name === 'AbortError') {
              throw new Error("Request timed out. Please check your connection and try again.");
            }
            if (error.name === 'TypeError' && error.message.includes('fetch')) {
              throw new Error("Network error. Please check your internet connection.");
            }
            throw error;
          } finally {
            clearTimeout(timeoutId);
          }
        }

        async fetchDrivingData(isManual = false) {
          // Don't fetch if addresses are not configured
          if (!this.configManager.hasValidAddresses()) {
            this.showLoading("to-time", "Not configured");
            this.showLoading("to-distance", "-");
            this.showLoading("from-time", "Not configured");
            this.showLoading("from-distance", "-");
            return;
          }

          // Show loading state
          if (isManual || this.state.lastRequestTimeDriving === 0) {
            this.showLoading("to-time", "Loading...");
            this.showLoading("from-time", "Loading...");
          }

          try {
            this.state.lastRequestTimeDriving = Date.now();
            this.clearError();

            // Validate and sanitize addresses before sending
            const homeAddress = SecurityUtils.sanitizeInput(this.config.homeAddress);
            const destinationAddress = SecurityUtils.sanitizeInput(this.config.destinationAddress);

            if (!SecurityUtils.validateAddress(homeAddress) || !SecurityUtils.validateAddress(destinationAddress)) {
              throw new Error("Invalid address format. Please check your settings.");
            }

            const url = new URL(this.constants.ENDPOINTS.DRIVING);
            url.searchParams.append("origin", homeAddress);
            url.searchParams.append("destination", destinationAddress);

            const data = await this.fetchWithTimeout(url.toString());

            // Validate response structure
            if (!data.to || !data.from || !data.to.duration || !data.from.duration) {
              throw new Error("Invalid response format from server");
            }

            this.updateDrivingUI(data);
            this.startUpdateCountdown("driving");
          } catch (error) {
            console.error("Driving data fetch error:", error);

            // Show user-friendly error message
            this.showError(error.message);

            // Show fallback UI
            this.showLoading("to-time", "Error");
            this.showLoading("from-time", "Error");
            this.showLoading("to-distance", "-");
            this.showLoading("from-distance", "-");

            // Retry logic for automatic fetches
            if (!isManual) {
              const retryDelay = this.getRetryDelay(error);
              setTimeout(() => this.fetchDrivingData(), retryDelay);
            }
          }
        }

        async fetchMBTAData(isManual = false) {
          // Show loading state
          if (isManual || this.state.lastRequestTimeMBTA === 0) {
            document.getElementById("trains").innerHTML = "<p>Loading train data...</p>";
          }

          try {
            this.state.lastRequestTimeMBTA = Date.now();
            this.clearError();

            const url = new URL(this.constants.ENDPOINTS.MBTA);
            url.searchParams.append("station", this.config.mbtaStation);

            // Include destination for walking time calculation (validate first)
            if (this.config.destinationAddress && SecurityUtils.validateAddress(this.config.destinationAddress)) {
              const sanitizedDestination = SecurityUtils.sanitizeInput(this.config.destinationAddress);
              url.searchParams.append("destination", sanitizedDestination);
            }

            const data = await this.fetchWithTimeout(url.toString());

            // Validate response structure
            if (!data.predictions) {
              throw new Error("Invalid MBTA response format");
            }

            this.updateMBTAUI(data);
            this.startUpdateCountdown("mbta");
          } catch (error) {
            console.error("MBTA data fetch error:", error);

            // Show user-friendly error message
            this.showError(error.message);

            // Show fallback UI
            document.getElementById("trains").innerHTML = `<p style="color: #ff0000;">Error loading train data: ${SecurityUtils.escapeHtml(error.message)}</p>`;

            // Hide walking info on error
            document.getElementById("walking-info").style.display = "none";

            // Retry logic for automatic fetches
            if (!isManual) {
              const retryDelay = this.getRetryDelay(error);
              setTimeout(() => this.fetchMBTAData(), retryDelay);
            }
          }
        }

        getRetryDelay(error) {
          // Implement exponential backoff for different error types
          if (error.message.includes("Rate limit")) {
            return 60000; // 1 minute for rate limiting
          }
          if (error.message.includes("Server error") || error.message.includes("temporarily unavailable")) {
            return 120000; // 2 minutes for server errors
          }
          if (error.message.includes("timeout")) {
            return 45000; // 45 seconds for timeouts
          }
          return 30000; // Default 30 seconds
        }

        updateDrivingUI(data) {
          // Handle error response from /all endpoint
          if (data.error) {
            this.showLoading("to-time", "Service Error");
            this.showLoading("from-time", "Service Error");
            this.showLoading("to-distance", "-");
            this.showLoading("from-distance", "-");
            return;
          }

          const { formatDuration, formatDistance, drivingTimeClass } =
            this.constructor.formatters;

          try {
            const drivingToSec = parseInt(data.to.duration.replace("s", ""), 10);
            const drivingFromSec = parseInt(
              data.from.duration.replace("s", ""),
              10
            );

            if (isNaN(drivingToSec) || isNaN(drivingFromSec)) {
              throw new Error("Invalid duration data received");
            }

            this.updateElement(
              "to-time",
              formatDuration(drivingToSec),
              drivingTimeClass(drivingToSec)
            );
            this.updateElement(
              "to-distance",
              formatDistance(data.to.distanceMeters || 0)
            );
            this.updateElement(
              "from-time",
              formatDuration(drivingFromSec),
              drivingTimeClass(drivingFromSec)
            );
            this.updateElement(
              "from-distance",
              formatDistance(data.from.distanceMeters || 0)
            );

            // Update timestamp if available
            if (data.timestamp) {
              document.getElementById("timestamp").textContent = new Date(
                data.timestamp
              ).toLocaleString();
            }

            // Update cache status
            const cacheStatus = document.getElementById("cache-status");
            if (data.cached) {
              cacheStatus.textContent = `Cached (${Math.ceil(
                data.cacheTTL || 0
              )} sec remaining)`;
              cacheStatus.className = "cache-status cache-stale";
            } else {
              cacheStatus.textContent = "Fresh";
              cacheStatus.className = "cache-status cache-fresh";
            }
          } catch (error) {
            console.error("Error updating driving UI:", error);
            this.showLoading("to-time", "Data Error");
            this.showLoading("from-time", "Data Error");
            this.showLoading("to-distance", "-");
            this.showLoading("from-distance", "-");
          }
        }

        updateElement(id, text, className = "") {
          const element = document.getElementById(id);
          element.textContent = text;
          if (className) element.className = className;
        }

        updateMBTAUI(data) {
          const trainsDiv = document.getElementById("trains");
          const walkingDiv = document.getElementById("walking-info");
          const walkingText = document.getElementById("walking-text");

          // Handle error response from /all endpoint
          if (data.error) {
            trainsDiv.innerHTML = `<p style="color: #ff0000;">MBTA Service Error: ${SecurityUtils.escapeHtml(data.error)}</p>`;
            walkingDiv.style.display = "none";
            return;
          }

          try {
            const { predictions, walkingTime } = data;

            // Display walking time if available
            if (walkingTime && this.config.destinationAddress) {
              walkingDiv.style.display = "block";
              const walkMinutes = walkingTime.minutes || 0;
              const walkDistance = walkingTime.distance ? (walkingTime.distance / 1609.344).toFixed(1) : "0.0";
              walkingText.textContent = `Walking time to station: ${walkMinutes} minute${
                walkMinutes !== 1 ? "s" : ""
              } (${walkDistance} miles)`;
            } else {
              walkingDiv.style.display = "none";
            }

            if (!predictions || !Array.isArray(predictions) || predictions.length === 0) {
              trainsDiv.innerHTML = "<p>No train predictions available</p>";
              return;
            }

            const northbound = predictions.filter(
              (p) => p && p.direction === "Northbound"
            );
            const southbound = predictions.filter(
              (p) => p && p.direction === "Southbound"
            );

            const createDirectionHTML = (trains, direction) => {
              const symbol = direction === "Northbound" ? "‚Üë" : "‚Üì";
              const destination =
                direction === "Northbound" ? "Alewife" : "Ashmont/Braintree";

              const predictions = trains
                .map((p) => {
                  try {
                    return this.constructor.formatters.formatPrediction(p, walkingTime);
                  } catch (error) {
                    console.error("Error formatting prediction:", error, p);
                    return null;
                  }
                })
                .filter(Boolean)
                .join(" | ");

              return `
        <div class="train-direction">
          ${symbol} <i>${SecurityUtils.escapeHtml(destination)}</i>: ${predictions || "No predictions"}
        </div>
          `;
            };

            trainsDiv.innerHTML = `
          <div class="train-time">
            ${createDirectionHTML(northbound, "Northbound")}
            ${createDirectionHTML(southbound, "Southbound")}
          </div>
        `;
          } catch (error) {
            console.error("Error updating MBTA UI:", error);
            trainsDiv.innerHTML = "<p style=\"color: #ff0000;\">Error displaying train data</p>";
            walkingDiv.style.display = "none";
          }
        }

        startUpdateCountdown(type) {
          if (this.state.timers[type]) {
            clearInterval(this.state.timers[type]);
          }

          const config = {
            driving: {
              duration: this.constants.UPDATE_INTERVAL_DRIVING,
              updateSpan: "next-update",
              fetchFn: () => this.fetchDrivingData(),
            },
            mbta: {
              duration: this.constants.UPDATE_INTERVAL_MBTA,
              updateSpan: "next-update-mbta",
              fetchFn: () => this.fetchMBTAData(),
            },
          }[type];

          let timeLeft = Math.floor(config.duration / 1000);
          const updateSpan = document.getElementById(config.updateSpan);

          this.state.timers[type] = setInterval(() => {
            timeLeft -= 1;
            if (timeLeft <= 0) {
              updateSpan.textContent = "Updating...";
              clearInterval(this.state.timers[type]);
              config.fetchFn();
            } else {
              updateSpan.textContent = `${timeLeft} seconds`;
            }
          }, 1000);

          updateSpan.textContent = `${timeLeft} seconds`;
        }

        static formatters = {
          formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = seconds % 60;
            return `${hours}:${minutes
              .toString()
              .padStart(2, "0")}:${remainingSeconds
              .toString()
              .padStart(2, "0")}`;
          },

          formatDistance(meters) {
            const miles = (meters / 1609.344).toFixed(2);
            return `${miles} miles`;
          },

          drivingTimeClass(timeSec) {
            if (timeSec > 40 * 60) return "very-long-drive-time";
            if (timeSec > 30 * 60) return "long-drive-time";
            return "";
          },

          formatPrediction(prediction, walkingTime) {
            if (!this.showTimePrediction(prediction.arrival)) return null;

            const timeUntil = this.formatTimeUntil(prediction.arrival);
            const minutesUntil = this.getMinutesUntil(prediction.arrival);

            // Determine if train is catchable based on walking time
            let catchableClass = "";
            if (walkingTime && minutesUntil !== null) {
              if (minutesUntil < walkingTime.minutes) {
                catchableClass = "train-missed";
              } else if (minutesUntil <= walkingTime.minutes + 2) {
                // Close call - might be tight
                catchableClass = "";
              } else {
                catchableClass = "train-catchable";
              }
            }

            return `
        <span class="${catchableClass}">
          ${timeUntil}
        </span>
        ${
          prediction.status
            ? `<span class="train-status">${prediction.status}</span>`
            : ""
        }
        `;
          },

          getMinutesUntil(arrivalTime) {
            if (!arrivalTime) return null;
            const arrival = new Date(arrivalTime);
            const now = new Date();
            return Math.round((arrival - now) / (1000 * 60));
          },

          showTimePrediction(arrivalTime) {
            if (!arrivalTime) return false;
            const arrival = new Date(arrivalTime);
            const now = new Date();
            const diffMinutes = Math.round((arrival - now) / (1000 * 60));
            return diffMinutes > -1;
          },

          formatTimeUntil(arrivalTime) {
            const arrival = new Date(arrivalTime);
            const now = new Date();
            const diffMinutes = Math.round((arrival - now) / (1000 * 60));

            if (diffMinutes < -1) return `${-diffMinutes} minutes ago`;
            if (diffMinutes <= 0) return "Now";
            if (diffMinutes === 1) return "1 minute";
            return `${diffMinutes} minutes`;
          },
        };
      }

      // Initialize the application
      const app = new TravelTimeMonitor();

      // Settings UI functions
      function toggleSettings() {
        const content = document.getElementById("settings-content");
        const toggle = document.getElementById("settings-toggle");
        content.classList.toggle("open");
        toggle.classList.toggle("open");
      }

      function saveSettings() {
        const homeAddressRaw = document.getElementById("home-address").value;
        const destinationAddressRaw = document.getElementById("destination-address").value;
        const mbtaStation = document.getElementById("mbta-station").value;

        // Sanitize inputs
        const homeAddress = SecurityUtils.sanitizeInput(homeAddressRaw);
        const destinationAddress = SecurityUtils.sanitizeInput(destinationAddressRaw);

        // Comprehensive validation
        if (!homeAddress || !destinationAddress) {
          app.showError("Please enter both home and destination addresses");
          return;
        }

        // Security validation
        if (!SecurityUtils.validateAddress(homeAddress)) {
          app.showError("Home address format is invalid or contains unsafe characters. Please enter a valid street address.");
          return;
        }

        if (!SecurityUtils.validateAddress(destinationAddress)) {
          app.showError("Destination address format is invalid or contains unsafe characters. Please enter a valid street address.");
          return;
        }

        // Check if inputs were modified during sanitization (potential security issue)
        if (homeAddressRaw.trim() !== homeAddress) {
          app.showError("Home address contains invalid characters that were removed. Please review and save again.");
          // Update the input field to show the sanitized version
          document.getElementById("home-address").value = homeAddress;
          return;
        }

        if (destinationAddressRaw.trim() !== destinationAddress) {
          app.showError("Destination address contains invalid characters that were removed. Please review and save again.");
          // Update the input field to show the sanitized version
          document.getElementById("destination-address").value = destinationAddress;
          return;
        }

        // Validate MBTA station selection
        const validStations = [
          "place-knncl", "place-chmnl", "place-pktrm", "place-dwnxg",
          "place-sstat", "place-harsq", "place-portr", "place-davis",
          "place-cntsq", "place-asmnl", "place-jfk", "place-andrw", "place-brdwy"
        ];

        if (!validStations.includes(mbtaStation)) {
          app.showError("Invalid MBTA station selected");
          return;
        }

        // Save configuration
        try {
          app.updateConfig({
            homeAddress,
            destinationAddress,
            mbtaStation,
            mbtaStationName: app.configManager.getStationName(mbtaStation),
          });

          app.showSuccess("Settings saved successfully! Refreshing data...");

          // Refresh data after a brief delay
          setTimeout(() => {
            app.handleManualRefresh();
          }, 500);

          setTimeout(() => {
            toggleSettings();
          }, 1000);
        } catch (error) {
          console.error("Error saving settings:", error);
          app.showError("Failed to save settings. Please try again.");
        }
      }

      function resetSettings() {
        if (confirm("Reset all settings to defaults?")) {
          const defaults = app.configManager.reset();
          app.config = defaults;
          app.loadSettingsUI();
          app.updateUIWithConfig();
          app.showError("Settings reset to defaults");
          app.handleManualRefresh();
        }
      }
    </script>
  </body>
</html>
